"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = require("path");
const fs_1 = require("fs");
const object_1 = tslib_1.__importDefault(require("@tinkoff/utils/is/object"));
const map_1 = tslib_1.__importDefault(require("./map"));
const getTypeAlias_1 = tslib_1.__importDefault(require("./getTypeAlias"));
const mustache_1 = tslib_1.__importDefault(require("mustache"));
const dirTree_1 = tslib_1.__importDefault(require("./dirTree"));
const parse_1 = require("./parse");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
function generateTypes({ types, config }) {
    const { projectDir, outputFilename = 'types/domain.d.ts' } = config;
    writeFile(path_1.join(projectDir, outputFilename), `${Object.values(map_1.default(stringifyNamespace, types)).join('')}\n`);
}
exports.generateTypes = generateTypes;
function generatingActionsTypes({ methods, types, config, }) {
    const { projectDir } = config;
    const available = new Set(Object.keys(methods));
    const typesDir = path_1.join(projectDir, `types`);
    dirTree_1.default(typesDir)
        .children.filter(({ name }) => /\.template\./.test(name))
        .forEach((x) => {
        const template = fs_1.readFileSync(path_1.join(typesDir, x.path))
            .toString()
            .replace(/\$(\w+)\$/g, '/*?{$1}?*/');
        const output = mustache_1.default.render(template, {
            methods: [...available].map((method) => {
                const { responses, parameters } = methods[method];
                return {
                    method,
                    responses: responses && responses.type,
                    parameters: parameters && parameters.type,
                };
            }),
        }, undefined, ['/*?', '?*/']);
        writeFile(path_1.join(typesDir, x.name.replace('.template', '')), output);
    });
}
exports.generatingActionsTypes = generatingActionsTypes;
function writeFile(path, contents) {
    fs_1.mkdir(path_1.dirname(path), (err) => {
        if (err) {
            // tslint:disable-next-line:no-console
            console.log(`[${chalk_1.default.yellow('WARNING')}] Can't mkdir for ${path_1.dirname(path)} ${err}`);
        }
        try {
            fs_1.writeFileSync(path, autogeneratedHeaders(contents));
            console.log(`[${chalk_1.default.green('SUCCESS')}] Types (${path}) have been successfully written. ðŸŽ‰`);
        }
        catch (e) {
            console.log(`[${chalk_1.default.red('ERROR')}] Can't write file for ${path} ${e}`);
        }
    });
}
function autogeneratedHeaders(content) {
    return "/**\n" +
        "** This file was generated automatically by @tinkoff/invest-types-generator\n" +
        "** do not try amending it manually\n" +
        "**/\n\n" + content;
}
function stringifyNamespace(name, keys) {
    const body = Object.values(map_1.default(stringifyType, keys));
    if (name === 'default') {
        return body.filter(Boolean).join('\n\n');
    }
    if (!body) {
        return `declare namespace ${name} {}`;
    }
    return `declare namespace ${name} {\n    ${body
        .join('\n\n    ')
        .replace(/;\n/g, ';\n    ')
        .replace(/{\n/g, '{\n    ')}\n}`;
}
function escapeNumbers(name) {
    return /\d/.test(name[0]) ? `'${name}'` : name;
}
function stringifyType(name, keys, isInnerType = false) {
    if (keys[parse_1.allOfTypesSymbol]) {
        const allOfTypesString = keys[parse_1.allOfTypesSymbol].join(' & ');
        if (isInnerType) {
            return `${name} = ${allOfTypesString};`;
        }
        return `export type ${name} = ${allOfTypesString};`;
    }
    if (keys[parse_1.EnumSymbol]) {
        if (isInnerType) {
            return `${name} = ${keys[parse_1.EnumSymbol]};`;
        }
        return `export type ${name} = ${keys[parse_1.EnumSymbol]};`;
    }
    const body = Object.values(map_1.default((prop, type) => {
        if (object_1.default(type)) {
            return stringifyType(prop, type, true);
        }
        return `${escapeNumbers(propAlias(prop))}${getTypeAlias_1.default(type)};`;
    }, keys)).join(`\n    ${isInnerType ? '    ' : ''}`);
    if (isInnerType) {
        if (!body) {
            return `${name}: {};`;
        }
        return `${name}: {\n        ${body}\n    };`;
    }
    if (!body) {
        return `export type ${name} = {};`;
    }
    return `export type ${name} = {\n    ${body}\n};`;
}
function propAlias(prop) {
    if (/^\d+.*/.test(prop)) {
        return `'${prop}'`;
    }
    return prop;
}
//# sourceMappingURL=generate.js.map